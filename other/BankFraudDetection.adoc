

== Bank Fraud Graph Data Model

Graph databases have emerged as an ideal tool for overcoming these hurdles. Languages like Cypher provide a simple semantic for detecting rings in the graph, navigating connections in memory, in real time. 

The graph data model below represents how the data actually looks to the graph database, and illustrates how one can find rings by simply walking the graph:

image::https://raw.github.com/neo4j-contrib/gists/master/other/images/BankFraud-1.png[Bank Fraud]

'''

== Sample Data Set

//setup
[source,cypher]
----

// Create Organizations
CREATE (MoCI:Organization {
	Name: "Ministry of Commerce and Industry",
	Abbrevation: "MoCI"})

CREATE (ROP:Organization {
	Name: "Royal Oman Police",
	Abbrevation: "ROP"})

// Create DataSets
CREATE (PersonData: DataSet {
	Name: "Person Data")}

CREATE (CRData: DataSet {
	Name: "CR Data")}

// Define data set owner
CREATE (MoCI)-[:OWNS_DATASET]->(CRData)

CREATE (ROP)-[:OWNS_DATASET]->(PersonData)

//Define data set consumer
CREATE (MoCI)-[IS_CONSUMING]->(PersonData)

RETURN *
----

//graph

'''

== Entity Link Analysis

Performing entity link analysis on the above data model is demonstrated below.

==== Find account holders who share more than one piece of legitimate contact information

[source,cypher]
----
MATCH 		(accountHolder:AccountHolder)-[]->(contactInformation) 
WITH 		contactInformation, 
			count(accountHolder) AS RingSize 
MATCH 		(contactInformation)<-[]-(accountHolder) 
WITH 		collect(accountHolder.UniqueId) AS AccountHolders, 
			contactInformation, RingSize
WHERE 		RingSize > 1 
RETURN 		AccountHolders AS FraudRing, 
			labels(contactInformation) AS ContactType, 
			RingSize
ORDER BY 	RingSize DESC
----

//output
//table

==== Determine the financial risk of a possible fraud ring

[source,cypher]
----
MATCH 		(accountHolder:AccountHolder)-[]->(contactInformation) 
WITH 		contactInformation, 
			count(accountHolder) AS RingSize 
MATCH 		(contactInformation)<-[]-(accountHolder), 
			(accountHolder)-[r:HAS_CREDITCARD|HAS_UNSECUREDLOAN]->(unsecuredAccount)
WITH 		collect(DISTINCT accountHolder.UniqueId) AS AccountHolders, 
			contactInformation, RingSize,
			SUM(CASE type(r)
				WHEN 'HAS_CREDITCARD' THEN unsecuredAccount.Limit
				WHEN 'HAS_UNSECUREDLOAN' THEN unsecuredAccount.Balance
				ELSE 0
			END) as FinancialRisk
WHERE 		RingSize > 1
RETURN 		AccountHolders AS FraudRing, 
			labels(contactInformation) AS ContactType, 
			RingSize, 
			round(FinancialRisk) as FinancialRisk
ORDER BY 	FinancialRisk DESC
----

//output
//table
